//
//  MarkerRole.swift
//  MarkersExtractor â€¢ https://github.com/TheAcharya/MarkersExtractor
//  Licensed under MIT License
//

import Foundation
import DAWFileKit

/// Marker Role.
///
/// Note that role names cannot include a dot (`.`) or a question mark (`?`).
/// This is enforced by Final Cut Pro because they are reserved characters for encoding the string
/// in FCPXML.
public enum MarkerRole: Hashable, Equatable, Sendable {
    case video(String)
    case audio(String)
}

extension MarkerRole: CustomStringConvertible {
    public var description: String {
        stringValue
    }
    
    var stringValue: String {
        switch self {
        case let .video(string):
            return string
        case let .audio(string):
            return string
        }
    }
}

extension MarkerRole {
    var isVideo: Bool {
        guard case .video = self else {
            return false
        }
        return true
    }
    
    var isAudio: Bool {
        guard case .audio = self else {
            return false
        }
        return true
    }
}

extension Array where Element == MarkerRole {
    func flattenedString() -> String {
        map(\.stringValue)
            .joined(separator: ", ")
    }
}

// MARK: MarkerRoles

/// Marker Roles for an element.
///
/// Note that role names cannot include a dot (`.`) or a question mark (`?`).
/// This is enforced by Final Cut Pro because they are reserved characters for encoding the string
/// in FCPXML.
public struct MarkerRoles: Equatable, Hashable, Sendable {
    public var video: FinalCutPro.FCPXML.VideoRole?
    public var isVideoDefault: Bool
    
    public var audio: FinalCutPro.FCPXML.AudioRole?
    public var isAudioDefault: Bool
    
    // TODO: add caption role
    
    public init(
        video: FinalCutPro.FCPXML.VideoRole? = nil,
        isVideoDefault: Bool = false,
        audio: FinalCutPro.FCPXML.AudioRole? = nil,
        isAudioDefault: Bool = false,
        collapseSubroles: Bool = false
    ) {
        if collapseSubroles {
            self.video = video?.collapsedSubRole()
        } else {
            self.video = video
        }
        self.isVideoDefault = isVideoDefault
        
        if collapseSubroles {
            self.audio = audio?.collapsedSubRole()
        } else {
            self.audio = audio
        }
        self.isAudioDefault = isAudioDefault
    }
    
    @_disfavoredOverload
    public init(
        video rawVideoRole: String? = nil,
        isVideoDefault: Bool = false,
        audio rawAudioRole: String? = nil,
        isAudioDefault: Bool = false,
        collapseSubroles: Bool = false
    ) {
        var videoRole: FinalCutPro.FCPXML.VideoRole? = nil
        if let rawVideoRole = rawVideoRole {
            videoRole = FinalCutPro.FCPXML.VideoRole(rawValue: rawVideoRole)
        }
        
        var audioRole: FinalCutPro.FCPXML.AudioRole? = nil
        if let rawAudioRole = rawAudioRole {
            audioRole = FinalCutPro.FCPXML.AudioRole(rawValue: rawAudioRole)
        }
        
        self.init(
            video: videoRole,
            isVideoDefault: isVideoDefault,
            audio: audioRole,
            isAudioDefault: isAudioDefault,
            collapseSubroles: collapseSubroles
        )
    }
}

// MARK: - Methods

extension MarkerRoles {
    /// Has a non-empty video role.
    public var isVideoEmpty: Bool {
        video == nil || video?.rawValue.isEmpty == true
    }
    
    /// Has a defined (non-default) video role.
    public var isVideoDefined: Bool {
        !isVideoEmpty && !isVideoDefault
    }
    
    /// Has a non-empty audio role.
    public var isAudioEmpty: Bool {
        audio == nil || audio?.rawValue.isEmpty == true
    }
    
    /// Has a defined (non-default) audio role.
    public var isAudioDefined: Bool {
        !isAudioEmpty && !isAudioDefault
    }
    
    static let notAssignedRoleString = "Not Assigned"
    
    public func videoFormatted() -> String {
        if let video = video, !video.rawValue.isEmpty {
            return video.rawValue
        }
        return Self.notAssignedRoleString
    }
    
    public func audioFormatted() -> String {
        if let audio = audio, !audio.rawValue.isEmpty {
            return audio.rawValue
        }
        return Self.notAssignedRoleString
    }
}

// MARK: - Subroles

extension MarkerRoles {
    /// Strip off subrole if subrole is redundantly generated by FCP.
    /// ie: A role of "Role.Role-1" would return "Role"
    public mutating func collapseSubroles() {
        video = video?.collapsedSubRole()
        audio = audio?.collapsedSubRole()
    }
    
    /// Strip off subrole if subrole is redundantly generated by FCP.
    /// ie: A role of "Role.Role-1" would return "Role"
    public func collapsedSubroles() -> Self {
        var copy = self
        copy.collapseSubroles()
        return copy
    }
}

// MARK: - MarkerRoleType

public enum MarkerRoleType: String, CaseIterable, Equatable, Hashable, Sendable {
    case video
    case audio
    // TODO: add `case caption`
}
